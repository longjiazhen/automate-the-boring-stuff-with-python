网不好的时候：
pip --default-timeout=100 install gevent


第一部分 python编程基础
 
Python IDLE 交互式环境，也就是输一句代码，回车就能看到运行结果
快捷键 Control+Command+Q 进入锁屏状态
command + control + f 退出全屏模式（即esc的功能）
 
mac os 下，使用文本编辑器的话，首行加上 #! /usr/bin/env python3 然后在命令行里给文件加执行权限，后来用 ./ 运行
 
for i in range(0, 5):
       print(i) #输出结果是0,1,2,3,4
for i in range(0, 5, 2):
       print(i) #输出结果是0,2,4
 
输出5个1-10之间的随机数（包括1也包括10）
import random
for i in range(5):
print(random.randint(1, 10))
调用sys中的exit函数来退出
import sys
sys.exit()
round()四舍五入
abs()绝对值
 
对所有没有return语句的函数，python都会默认加上return None。类型是NoneType。就像while或者for循环默认以continue结尾一样。如果只用return关键字本身，不带返回值，也是返回None
 
print函数有2个可选参数，一是sep，默认为空格，表示2个字符串之间以什么分隔，二是end，默认是换行，表示字符串最后以什么结尾
 

案例：
li = [0, 1, 2, 3, 4, 5, 6, 7, 8]
print("li[-1:]: ", li[-1:])
print("li[:-1]: ", li[:-1])
print("li[0:2]: ", li[0:2])
结果：
li[-1:]: [8]
li[:-1]: [0, 1, 2, 3, 4, 5, 6, 7]
li[0:2]: [0, 1]
对列表使用-1下标，表示最后一个，-2表示倒数第二个，等等
spam = [0,1,2,3,4,5,6,7,8,9]
spam[2] 是取spam列表中，下标为2的那个值
利用切片取得子列表：
切片中，第一个整数是切片开始的下标，第二个整数是切片结束的下标。包括第一个下标，不包括第二个。如果省略第一个，默认为0；如果省略第二个，默认至列表末尾。
spam[1:4] 是取spam列表中，下标1-4，包括1不包括4的值
spam[0:-1] 是取spam列表中，下标0-9，包括0不包括9的值
用del语句从列表中删除值，比如del spam[2]
 
可以先定义一个空的列表 CatNames = []
然后逐个输入列表元素，name = input('')
将新输入的元素附加到列表末尾 CatNames = CatNames + [name]
 
多重赋值：用列表中的值为多个变量赋值
spam = ['a', 'b', 'c', 'd']
A, B, C, D = spam
等价于A = 'a', B = 'b', C = 'c', D = 'd'
 
用index()方法在列表中查找值
spam.index('d') = 3  元素a在列表中对应的下标是3
如果列表中存在相同的值，则返回它第一次出现的下标
 
用append()和insert()方法在列表中添加值
append()是追加到末尾  spam.append('a1')
insert()是添加在指定位置 spam.insert(1, 'b1')
 
用remove()从列表中删除值，多次出现的话，只会删除第一个 spam.remove('a1')
用del删除指定位置的值 del spam[1]
 
用sort() 方法将列表中的值排序
spam.sort() 正序排序，列表可以仅含数字或者仅含字符，不能同时包含
spam.sort(reverse=True) 逆序排序
sort() 排序是按ASCII表顺序来的，大写字母排在小写字母之前，即Z在a之前
如果想按普通字典顺序排列，用spam.sort(key=str.lower)或者upper，这样sort()方法会将列表中的所有表项当作小写/大写，实际上并不会改变它们的值。这样大写在前还是小写在前，取决于它们在列表中的出现顺序。
 
可以在一行后面加续行字符\，将一条指令写成多行，续行字符的下一行缩进不重要
print('Four score and seven ' + \
      'years ago...')
 
字符串（spam = 'Hello'）是单个文本字符的列表，对列表的按下标取值（spam[1]）、切片（spam[0:2]）、用于for循环（for i in spam）、用len()求长度（len(spam)）、用于in和not in操作符（'H' in spam），这些都可以作用于字符串
 
但是不能对字符串中的某个字符进行重新赋值，如spam[0] = 'A'。想要一个“新的“字符串可以用切片和连接，比如ewSpam = 'A' + spam[1:]。
 
元组和列表的区别在于：1.元组使用圆括号()，而不是方括号[]
2.元组和字符串一样，都是不可变的
 
str(42) 将整型的42转换成字符型'42'
list(('a', 'b', 'c')) 将元组转换成列表
tuple(['A', 'B', 'C']) 将列表转换成元组
 
列表的赋值，不是真的拷贝了列表本身，而是拷贝了对列表的引用。即，已有列表A，将A赋值给B，然后修改B，会把A也一起改了。
把列表作为参数传递给函数的时候，也是直接把原列表本身给改了：
def eggs(someParameter):
    someParameter.append('Hello')
spam = [1, 2, 3]
eggs(spam)
print(spam)
输出结果为 [1, 2, 3, 'Hello']
不想改动原列表的话，可以使用copy()模块的copy()和deepcopy()函数
B = copy.copy(A) 是创建了第二个列表，所以修改B就不会再影响到A了
如果要赋值的列表中还包含列表，那就使用copy.deepcopy()来代替，deepcopy()将同时复制它们内部的列表（如果只用copy.copy() 没有复制成功，还是改了原有列表）
 
字典 spam = {'key1': 'value1', 'key2': 'value2'} 无序的
for v in spam.values():
       print(v) #打印字典中的所有value
for k in spam.keys():
       print(v) #打印字典中的所有key
for i in spam.items():
       print(v) #打印字典中的所有item（key, value）
检查字典中是否存在键或值：
'key1' in spam() 或者 'key1' in spam.keys()
'value1' in spam.values()
 
字典的get()方法需要2个参数，一是要取得其值的键，而是如果该键不存在，返回的备用值，spam.get('key3', 0)。如果不用get()方法，直接spam['key3']，key3不存在的话就会报错
 
setdefault()方法需要2个参数，一是需要检查的键，二是如果该键不存在时要设置的值，spam.setdefault('color', 'black') 。所以，如果连用2次setdefault()，第二次会不生效，因为该键已存在。不过还可以用spam['color'] = 'red'的方式来指定值
 
导入pprint模块，可以使用pprint()和pformat()函数，这样打印出来的结果更漂亮一些，会换行，键值按ASCII表排序
pprint.pprint(count) 这样直接打印到屏幕上
pprint.pformat(count) 这样得字符串
 
打印多行字符可以使用三重引号（3个单引号或者3个双引号），三重引号之间的所有引号、制表符、换行都被认为是字符串的一部分，python的代码块缩进规则不适用于多行字符串。
 
字符串方法upper()大写、lower()小写，没有改变字符串本身，而只是生成了新的字符串
isupper()、islower()如果字符串至少有一个字母，且所有字母为全大/小写，返回True
 
isalpha() 返回True，如果字符串只包含字母，且非空
isalnum() 返回True，如果字符串只包含字母和数字，且非空
isdecimal() 返回True，如果字符串只包含数字字符，且非空
isspace() 返回True，如果字符串只包含空格、制表符和换行，且非空
istitle() 返回True，如果字符串只包含以大写字母开头的单词
'A987123'.istitle()
 
startswith() 和 endswith() 返回True，如果它们所调用的字符串以该方法传入的字符串开始或结束
'helloworld'.startswith('hello')
 
使用join() 连接字符串，使用split() 分割字符串
注：一个字符串调用join()，需要的参数是一个列表，返回一个字符串 '*'.join(['a', 'b', 'c'])
一个字符串调用split()，需要的参数是一个字符串，不填的话默认按空白字符分割，如空格、制表符或换行符，返回一个列表
 
rjust() 和 ljust() 和center() 返回调用它们的字符串的填充版本，通过插入空格或者指定字符来对齐文本
'hello'.rjust(10, '*') 是说，希望得到一个长度为10的字符串，hello右对齐，hello本身长度为5，所以会在右边填充5个*
 
用lstrip() 和rstrip() 和 strip() 删除字符串左边/右边/两边的空白字符（空格、制表符和换行符），也可以带参数，表示哪些字符（顺序不重要）才该删除
 
用pyperclip模块的copy()和paste()函数拷贝粘贴字符串
pyperclip不是python自带的，需要先用 pip3 install pyperclip 来安装
#! /usr/bin/env python3
import pyperclip
temp = 'Hello world!'
pyperclip.copy(temp)
运行以后，在命令行、文本文件等地方用command+v都可以粘贴Hello world
在别的地方用command+c拷贝了字符串以后，回到python IDLE，输入pyperclip.paste()即可将拷贝内容粘贴出来
  
第二部分  自动化例子
七、模式匹配和正则表达式
（一）基本匹配
\d 是一个正则表达式（regex），表示一位数字字符，即一个从0-9的数字。所以，如果电话号码的格式时：3 个数字，一个短横线，3 个数字，一个短横线，再是 4 个数字。可以用 \d\d\d-\d\d\d-\d\d\d\d
{3} 表示匹配这个模式3次，所以上述也可写成 \d{3}-\d{3}-\d{4}
python中的正则表达式在re模块，所以要先import re
向re.compile() 传入一个字符串，表示正则表达式，返回Regex对象
Regex对象用search() 查找传入的字符串，寻找该正则表达式的所有匹配，如果没找到，返回None，如果找到了返回一个Match对象。Match对象有一个group() 方法，返回被查找字符串中实际匹配的文本。
在字符串的第一个引号之前加上r，表示将该字符串标记成原始字符串，它不包含转义字符串。如 r'\d{3}-\d{3}-\d{4}' 起到的作用与 '\\d{3}-\\d{3}-\\d{4}' 相同
总结：
用import re导入正则表达式模块
用re.compile() 函数创建一个Regex对象（记得使用原始字符）
想Regex对象的search() 方法传入想查找的字符串，它返回一个Match对象
调用Match对象的group() 方法，返回实际匹配文本的字符串
 
（二）更多匹配技巧
1. 利用括号分组
正则表达式字符串中的第一对括号是第1组，第二对括号是第2组。向group() 匹配对象方法传入整数1或者2，获取匹配文本的不同部分。传入0或者不传参数，获取整个匹配文本。如果想要一次性获取所有分组，用groups() 方法，注意复数，返回值是一个元组，可以使用多重赋值方法 a, b = mo.groups()
在正则表达式里，括号有特殊含义，所以为了匹配 (415)-555-4242 应该用上转义字符\，即 (\(\d\d\d\))-(\d\d\d-\d\d\d\d)
2. 用管道|匹配多个分组
使用管道可以匹配多个表达式中的第一个，如r'aaa|bb cc'将返回第一次匹配中的文本
使用findall() 方法可以找到所有匹配的地方
3.用问号?实现可选匹配
匹配这个问号之前的分组（括号里的叫分组）一次或者零次
4.用星号*匹配零次或者多次
5.用加号+匹配一次或者多次
6.用花括号{}匹配特定次数
(Ha){3} 匹配3次
(Ha){3, 5} 指定匹配的最小次数和最大次数，即3-5次，最大/最小次数之一可以省略
 
（三）贪心和非贪心匹配
python的正则表达式默认是贪心的，在有二义性的情况下，尽可能地匹配尽量长的字符串
非贪心是匹配尽可能短的字符串，在结束的花括号后面跟一个问号，(Ha){3, 5}?
注：问号有两种含义，一是表示可选的分组，二是表示非贪心匹配
 
（四）findall() 方法
search() 返回的是一个Match对象，findall() 返回的是一个列表
注：
如果正则表达式中没有分组（括号里的叫分组），findall() 返回一个匹配字符串的列表，例如['415-555-9999', '212-555-0000']
如果正则表达式里有分组，findall() 返回一个字符串的元组的列表（每个分组对应一个字符串），例如[('415', '555', '1122'), ('212', '555', '0000')]
for groups in phoneRegex.findall(temp) 这样每个groups就是一个分组
（五）字符分类
\d   0到9的任意数字（digit）
\D   除0到9数字以外的任何字符
\w   任何字母、数字或下划线字符（word）
\W   除字母、数字和下划线以外的任何字符
\s    空格、制表符或换行符（space）
\S   除空格、制表符和换行符以外的任何字符
 
（六）建立自己的字符分类
用方括号定义自己的字符分类，如 [aeiouAEIOU] 表示只匹配这几个字母
前面加^表示非，如 [^aeiouAEIOU] 表示匹配这几个字符以外的所有字符
表示a到z用 [a-z]
注：方括号之内的普通正则表达式符号不会被解释，即不需要加斜杠来转义*+等
 
（七）插入字符和美元字符
在开始处使用插入字符 ^ 表示匹配必须发生在被查找文本的开始处。举例：
如果匹配条件是 ^Hello
那么 Hello world 能匹配上，world Hello 匹配不上，Hworldello 也匹配不上
在末尾处使用美元字符 $ 表示匹配必须发生在被查找文本的开始处。举例：
如果匹配条件是 world$
那么 Hello world 能匹配上，world Hello 匹配不上，Hworldello 也匹配不上
同时使用^和$的话，表示整个字符串必须完整匹配该格式，只匹配该字符串的某个自己是不行的
 
（八）通配字符
句点 . 称为通配符，可以匹配除换行外的任意字符，只匹配一个字符。要想匹配真正的句点，需要用 \.
因为点可以匹配除换行以外的所有字符，星可以匹配零次或者多次，所以点星 .* 表示任意文本
点星 .* 默认使用贪心模式，匹配尽可能多的文本。点星问号 .*? 使用非贪心模式。
点星匹配除了换行以外的所有字符，再用re.DOTALL作为re.compile()的第二个参数，就可以匹配所有字符了，包括换行符 re.compile('.*', re.DOTALL)
 
（十）复习
? 匹配零次或者一次前面的分组
* 匹配零次或者多次前面的分组
+ 匹配一次或者多次前面的分组
{n} 匹配n次前面的分组
{n,} 匹配n次或更多次前面的分组
{,m} 匹配零次到m次前面的分组
{n,m} 匹配至少n次至多m次前面的分组
{n,m}? 或 *? 或 +? 对前面的分组进行非贪心匹配
^spam 意味着字符串必须以spam开始
spam$ 意味着字符串必须以spam结束
. 匹配所有字符串，换行符除外
\d \w \s分别匹配数字、单词和空格
\D \W \S分别匹配除数字、单词和空格以外的所有字符
[abc] 匹配方括号内的任意字符
[^abc] 匹配不在方括号内的所有字符
 
（十一）其他
1、不区分大小写的匹配：
用 re.IGNORECASE 或者 re.I 作为re.compile()的第二个参数即可
2、用sub() 方法替换字符串：
使用正则表达式查找到指定字符串，然后用新的字符串替换掉它们。sub(新的字符串，正则表达式)，返回值为替换完成之后的字符串
re.compile(r'Agent \w+') 表示匹配Agent加空格加下一个单词（到下一个空格为止）
使用匹配的文本本身作为替换的一部分。在sub()的第一个参数中，输入\1、\2、\3表示在替换中输入分组1、2、3的文本，例如：re.compile(r'Agent (\w)\w*') 表示匹配Agent加空格加下一个单词，分组1是下一个单词的首字母
3、忽略正则表达式字符串中的空白符和注释
如果需要用比较复杂的正则表达式，可以给re.compile()传入第二个参数re.verbose()，表示忽略第一个参数（正则表达式）中的空白符和注释，第一个参数里可以使用'''创建多行表达式
4、re.compile() 的第二个参数想用多个时，用管道|连接
re.VERBOSE 忽略注释和空白符
re.DOTALL 和 .* 一起用可以匹配所有字符
re.IGNORECASE 忽略大小写
 
（十二）习题
创建regex的对象的函数是：re.compile()
创建regex对象时，使用原始函数是为了：让反斜杠不必转义
search方法返回：Match对象
通过Match对象，如何得到匹配该模式的实际字符串：用group方法
在 r'(\d\d\d)-(\d\d\d-\d\d\d\d)' 中，分组0表示 (\d\d\d)-(\d\d\d-\d\d\d\d)，分组1表示 (\d\d\d)，分组2表示(\d\d\d-\d\d\d\d)
在正则表达式中，点表示匹配一个任意字符（除了换行符），括号用来表示分组，为了匹配真正的点或者括号，应该用转义字符
如果findall()参数中包含分组，则返回字符串元组的列表，如果不包含分组，则返回字符串列表。列表使用[]，元组使用()，元组和字符串一样，都是不可变的。
管道字符 | 用于匹配多个分组，表示匹配其中任意一个
问号 ? 有两种含义，一是匹配零次或一次，二是非贪心匹配
 *匹配零次或多次，+匹配一次或多次
{3} 匹配3次，{3, 5}匹配最少3次最多5次
\d 匹配0-9的数字，\w匹配数字字母下划线，\s匹配空格换行制表符
\D 匹配除了0-9数字以外的，\W 匹配除了数字字母下划线以外的，\S 匹配除了空格换行制表符以外的
re.compile() 的第二个参数为re.INGNORECASE 或者 re.I 可以忽略大小写
字符 . 匹配一个除了换行以外的任意字符，如果将re.DOTALL作为第二个参数传给re.compile()的话，可以匹配包括换行符在内的任意字符
点星 .* 匹配零个或者多个除了换行符以外的任意字符，*? 表示对前面的分组进行非贪心匹配
匹配所有数字和小写字母 [0-9a-z]
如果 numRegex = re.compile(r'\d+')，那么 numRegex.sub('X', '12 drummers, 11 pipers, five rings, 3 hens') 返回 X drummers, X pipers, five rings, X hens
将re.VERBOSE作为第二个参数传给re.compile()，可以忽略空白符和注释
写一个正则表达式，每匹配三个数字就有一个逗号，可以匹配：
· '42'             · '1,234'        · '6,368,745'
但是不会匹配：
· '12,34,567' (逗号之间只有两位数字)            · '1234' (缺少逗号)
答案：mRegex = re.compile(r'\d{1,3}(,\d{3})*$')
先匹配1-3个数字，然后再匹配零次或者多次 逗号加3个数字
匹配姓 Nakamoto 的完整姓名，假定名字总是出现在姓前面，是一个大写字母开头的单词。该正则表达式必须匹配:
·  'Satoshi Nakamoto'        ·  'Alice Nakamoto'    ·  'RoboCop Nakamoto'
但不匹配:
·  'satoshi Nakamoto'(名字没有大写首字母)
·  'Mr. Nakamoto'(前面的单词包含非字母字符)
·  'Nakamoto' (没有名字)
·  'Satoshi nakamoto'(姓没有首字母大写)
 
 
 